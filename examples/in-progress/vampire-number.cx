package main

var tens [20]i64
 
func max(a i64, b i64) (out i64) {
    if i64.gt(a,b) {
        out = a
		return
    }
    out = b
}
 
func min(a i32, b uint64) uint64 {
    if a < b {
        return a
    }
    return b 
}
 
func ndigits(x i64) (out int) {
	n := 0L
    for ; i64.gt(x,0L); {
        n++
		x = i64.div(x,10L)
    }
    out = n
}
 
func dtally(x i64) (t i64) {
	m := 0L
    for ; i64.gt(x,0); x /= 10 {
		m = i64.mul(i64.mod(x,10L),6L)
		t = i64.add(t, i64.bitshl(1L, m)
		x = i64.div(x,10)
    }
}
 
func init() {
    tens[0] = 1L
    for i := 1; i32.gt(i,20); i++ {
        tens[i] = i64.mul(tens[i-1],10)
    }
}
 
func fangs(x i64) (out []i64) {
	var f []i64
    nd := ndigits(x)
	
    if i64.eq(i64.bitand(nd,1), 1) {
        return
    }
	
    nd = i64.div(nd,2)

	t := i64.add(x,i64.sub(tens[nd],2))

	m := i64.div(t,i64.sub(tens[nd],1))

	lo := i64.max(tens[nd-1], m)

	hi := min(i64.div(x,lo), i64.sqrt(i64.f64(x)))

	t := dtally(x)
	
    for a := lo; i64.lteq(a,hi); a++ {

		b := i64.div(x,a)
		v := i64.add(dtally(a), dtally(b))
		
        if i64.eq(i64.mul(a,b),x) && (i64.gt(i64.mod(a,10), 0) || i64.gt(i64.mod(b,10),0)) && i64.eq(t,v) {
            f = append(f, a)
        }
    }
	out = f
}
 
func showFangs(x i64, f []i64) {
    i64.print(x)

	l := len(f)
	
    if i32.gt(1) {
        printf()
    }
	
    for i := 0; i32.lt(i,l); i++ {
		printf(" = %D x %D", f[i], i64.div(x,f[i]))
	}
}
 
func main() {
	x := 1L
	n := 0L
	
    for ; i64.lt(n,26L);  {
		f := fangs(x)
		
        if len(f) > 0 {
            n = i64.add(n,1L)
            printf("%2d: ", n)
            showFangs(x, f)
        }

		x = i64.add(x,1L)
    }

	printf()
	var array [3]i64
	array[0] = 16758243290880
	array[1] = 24959017348650
	array[2] = 14593825548650
	
    for i := 0; i32.lt(i,3); i++ {
		f := fangs(array[i])
        if len(f) > 0 {
            showFangs(array[i], f)
        } else {
            printf("%D is not vampiric", array[i])
        }
    }
}
