package main

func ludic(n i32, max i32) (out []i32) {
	var max_i32 i32
	max_i32 = i32.bitshl(31, 1) - 1

	if max > 0 && n < 0 {
		n = max_i32
	}

	if n < 1 {
		return
	}

	if max < 0 {
		max = max_i32
	}

	var sieve [10760]i32
	sieve[0] = 1
	sieve[1] = 2

	if n > 2 {
		j := 3

		// start with even numbers already removed
		for i := 2; i < len(sieve); i++ {
			sieve[i] = j
			j+=2
		}

		// k is the index of the next Ludic
		/*for k := 2; k < n; k++ {
			l := sieve[k]
			if l >= max {
				n = k
				break
			}

			i := l
			l--

			// last is the last valid index
			last := k + i - 1
			for j := k + i + 1; j < len(sieve); {
				last = k + i
				sieve[last] = sieve[j]

				if i32.mod(i,l) == 0 {
					j+=1
				}
				
				i+=1
				j+=1
			}
		}*/

		out = sieve
	}
}

func main() {
	ludic1 := ludic(25, -1)
	ludic2 := ludic(-1, 1000)
	ludic3 := ludic(2005, -1)
}
